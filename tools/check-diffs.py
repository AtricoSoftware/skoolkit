#!/usr/bin/env python3

import sys
import os
from os.path import isfile, basename
import re

def parse_args(args):
    if len(args) != 2:
        print_usage()
    exp_diffs_file, diff_file = args
    if not isfile(diff_file):
        sys.stderr.write('ERROR: {}: file not found\n'.format(diff_file))
        sys.exit(1)

    return diff_file, exp_diffs_file

def print_usage():
    sys.stderr.write("""Usage: {} exp-diffs.txt diffs.txt

  Examines a diff file generated by 'write-files' and filters out expected
  differences.

  The expected diffs file (exp-diffs.txt) may contain any of the following
  directives:

  ; @ExpIgnoreCase
      Ignore case in expected diffs. This will discard a generated diff if it
      differs from an expected diff only in case.

  ; @IgnoreAddressIndex=i
      Ignore an address at index 'i' in an expected diff. For every expected
      diff containing one or more lines 'd' with a decimal address at d[i:i+5],
      this will discard any generated diff that matches it with the decimal
      addresses replaced by hexadecimal addresses.

  ; @IgnoreCase
      Ignore case in generated diffs. This will discard a generated diff if the
      old lines and the new lines differ only in case.

  ; @IgnoreDiffsContaining=s
      Ignore generated diffs that contain 's'. This will discard a generated
      diff if it contains the substring 's' (case-insensitive).

  ; @IgnoreDiffsContainingRegex=r
      Ignore generated diffs that contain the regex 'r'. This will discard a
      generated diff if any part of it matches the regular expression 'r'.

  ; @IgnoreEquivalentDEFBs
      Ignore equivalent DEFB statements in generated diffs. This will discard a
      generated diff if its old lines and new lines contain equivalent DEFB
      statements (e.g. '-DEFB 0' and '+DEFB $00').

  ; @IgnoreFile=f
      Ignore generated diffs from a file whose name ends with 'f'.

  ; @IgnoreReverseSubstitution=/s/r
      Replace the string 's' with the string 'r' in the new lines of generated
      diffs. This will discard a generated diff if the new lines match the old
      lines after the replacement has been made.

  ; @IgnoreSubstitution=/s/r
      Replace the string 's' with the string 'r' in the old lines of generated
      diffs. This will discard a generated diff if the old lines match the new
      lines after the replacement has been made.

  ; @IgnoreWhitespace
      Ignore leading whitespace, trailing whitespace and blank lines in
      generated diffs. This will discard a generated diff if the old lines
      differ from the new lines only in the amount of leading/trailing
      whitespace or blank lines.

  ; @RegexReplace=/s/r
      Replace substrings that match the regular expression 's' with the regular
      expression 'r' in the old lines of generated diffs. This will discard a
      generated diff if the old lines match the new lines after the replacement
      has been made.
""".format(basename(sys.argv[0])))
    sys.exit(1)

def parse_int(num_str):
    try:
        if num_str[0] == '$':
            return int(num_str[1:], 16)
        return int(num_str)
    except:
        return None

def extract_bytes(line, index):
    num_strs = []
    num_str = ''
    while index < len(line):
        char = line[index].upper()
        if char not in ' ,0123456789$ABCDEF':
            break
        if char == ',':
            num_strs.append(num_str.strip())
            num_str = ''
        else:
            num_str += char
        index += 1
    if num_str:
        num_strs.append(num_str)
    bytes = [parse_int(num_str) for num_str in num_strs]
    return bytes, index

def equivalent_defbs(line1, line2):
    start1 = line1.upper().find('DEFB')
    if start1 < 0:
        return False
    start2 = line2.upper().find('DEFB')
    if start2 < 0:
        return False
    bytes1, end1 = extract_bytes(line1, start1 + 4)
    bytes2, end2 = extract_bytes(line2, start2 + 4)
    if bytes1 != bytes2:
        return False
    new_line1 = line1[:start1] + line1[end1:]
    new_line2 = line2[:start2] + line2[end2:]
    return new_line1 == new_line2

def remove_equivalent_defbs(lines1, lines2):
    old_lines = []
    new_lines = []
    for line1, line2 in zip(lines1, lines2):
        if not equivalent_defbs(line1, line2):
            old_lines.append(line1)
            new_lines.append(line2)
    return old_lines, new_lines

def get_diffs(fname, options=None, fnames=False):
    diffs = []
    with open(fname) as f:
        cur_file = fname if fnames else None
        last = None
        for line in f:
            s_line = line.rstrip('\n')
            if options is not None and s_line.startswith('; @'):
                option, sep, value = s_line[3:].rstrip().partition('=')
                if sep:
                    options.setdefault(option, []).append(value)
                else:
                    options[option] = True
                continue
            if s_line.startswith('--- '):
                continue
            if s_line.startswith('+++ ') and fnames:
                cur_file = s_line.split()[1]
            elif s_line and s_line[0] in '+-':
                if last is None:
                    diffs.append((cur_file, [], []))
                if s_line[0] == '-':
                    diffs[-1][1].append(s_line)
                else:
                    diffs[-1][2].append(s_line)
                last = s_line[0]
            else:
                last = None
    return diffs

def convert_addresses(lines, index):
    changed = False
    hex_lines = []
    for line in lines:
        try:
            address = int(line[index + 1:index + 6])
            hex_lines.append('{}${:04X}{}'.format(line[:index + 1], address, line[index + 6:]))
            changed = True
        except ValueError:
            hex_lines.append(line)
    return changed, hex_lines

def run(diff_file, exp_diffs_file):
    diffs = get_diffs(diff_file, fnames=True)
    options = {}
    exp_diffs = []
    if isfile(exp_diffs_file):
        exp_diffs = get_diffs(exp_diffs_file, options)
    ignore_case = options.get('IgnoreCase', False)
    ignore_exp_case = options.get('ExpIgnoreCase', False)
    ignore_whitespace = options.get('IgnoreWhitespace', False)
    subs = options.get('IgnoreSubstitution', ())
    rev_subs = options.get('IgnoreReverseSubstitution', ())
    regex_subs = options.get('RegexReplace', ())
    ignore_files = options.get('IgnoreFile', ())
    ignore_equivalent_defbs = options.get('IgnoreEquivalentDEFBs', False)
    ignore_strings = options.get('IgnoreDiffsContaining', ())
    ignore_regexes = options.get('IgnoreDiffsContainingRegex', ())
    ignore_address_indexes = options.get('IgnoreAddressIndex', ())

    for i in ignore_address_indexes:
        index = int(i)
        for _, old_lines, new_lines in exp_diffs[:]:
            old_changed, hex_old_lines = convert_addresses(old_lines, index)
            new_changed, hex_new_lines = convert_addresses(new_lines, index)
            if old_changed or new_changed:
                exp_diffs.append((None, hex_old_lines, hex_new_lines))

    if ignore_exp_case:
        for entry in exp_diffs:
            entry[1][:] = [s.lower() for s in entry[1]]
            entry[2][:] = [s.lower() for s in entry[2]]

    unexp_diffs = set()
    lines = []
    last_fname = None
    for fname, old, new in diffs:
        ignore = False
        for ignore_file in ignore_files:
            if fname.endswith(ignore_file):
                ignore = True
                break
        if ignore:
            continue

        old_lines = [line[1:] for line in old]
        new_lines = [line[1:] for line in new]

        ignore = False
        all_lines = old_lines + new_lines
        for substring in ignore_strings:
            string_l = substring.lower()
            if any(line.lower().find(string_l) >= 0 for line in all_lines):
                ignore = True
                break
        if ignore:
            continue
        for regex in ignore_regexes:
            if any(re.search(regex, line) for line in all_lines):
                ignore = True
                break
        if ignore:
            continue

        for sub in subs:
            substr, rep = sub[1:-1].split(sub[0])
            old_lines = [line.replace(substr, rep) for line in old_lines]

        for sub in rev_subs:
            substr, rep = sub[1:-1].split(sub[0])
            new_lines = [line.replace(substr, rep) for line in new_lines]

        for sub in regex_subs:
            pattern, rep = sub[1:-1].split(sub[0])
            old_lines = [re.sub(pattern, rep, line) for line in old_lines]

        if ignore_case:
            old_lines = [line.lower() for line in old_lines]
            new_lines = [line.lower() for line in new_lines]

        if ignore_whitespace:
            old_lines = [line.strip() for line in old_lines if line.strip()]
            new_lines = [line.strip() for line in new_lines if line.strip()]

        if ignore_equivalent_defbs and len(old_lines) == len(new_lines):
            old_lines, new_lines = remove_equivalent_defbs(old_lines, new_lines)

        if old_lines == new_lines:
            continue

        if ignore_exp_case:
            old_lines = [s.lower() for s in old]
            new_lines = [s.lower() for s in new]
        else:
            old_lines, new_lines = old, new
        for _, exp_old, exp_new in exp_diffs:
            if (old_lines, new_lines) == (exp_old, exp_new):
                break
        else:
            unexp_diff = (tuple(old), tuple(new))
            if unexp_diff in unexp_diffs:
                continue
            unexp_diffs.add(unexp_diff)
            if last_fname != fname:
                lines.append('+++ {}'.format(fname))
                last_fname = fname
            for line in old:
                lines.append(line)
            for line in new:
                lines.append(line)
            lines.append('')

    if lines:
        suffix = '' if isfile(exp_diffs_file) else ' (not found)'
        print('+ Expected diffs file: {}{}'.format(exp_diffs_file, suffix))
        print('+')
        for directive, value in (
            ('ExpIgnoreCase', ignore_exp_case),
            ('IgnoreAddressIndex', ignore_address_indexes),
            ('IgnoreCase', ignore_case),
            ('IgnoreDiffsContaining', ignore_strings),
            ('IgnoreDiffsContainingRegex', ignore_regexes),
            ('IgnoreEquivalentDEFBs', ignore_equivalent_defbs),
            ('IgnoreFile', ignore_files),
            ('IgnoreReverseSubstitution', rev_subs),
            ('IgnoreSubstitution', subs),
            ('IgnoreWhitespace', ignore_whitespace),
            ('RegexReplace', regex_subs)
        ):
            if isinstance(value, (list, tuple)):
                for val in value:
                    print('+ @{}={}'.format(directive, val))
            else:
                print('+ @{}={}'.format(directive, value))
        print('')
        print('\n'.join(lines))

def main():
    run(*parse_args(sys.argv[1:]))

if __name__ == '__main__':
    main()
